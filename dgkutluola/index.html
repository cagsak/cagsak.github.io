<!DOCTYPE html>
<html lang="tr">

<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="icon" href="../fotograflar/hacker.ico">
    <title>DG Kutluola</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com">
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700;900&display=swap" rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.0/p5.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Inter', sans-serif;
            overflow: hidden;
            background: #000;
        }

        canvas {
            display: block;
        }

        /* Header */
        header {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            z-index: 1000;
            background: rgba(0, 0, 0, 0.85);
            backdrop-filter: blur(12px);
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            padding: 1rem 2rem;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        header h1 {
            color: #fff;
            font-size: 1.5rem;
            font-weight: 700;
            background: linear-gradient(90deg, #e94560, #ff6b9d, #c44569);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            text-align: center;
        }

        /* Start overlay */
        #start-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.95);
            display: flex;
            justify-content: center;
            align-items: center;
            flex-direction: column;
            z-index: 3000;
        }

        #start-overlay.hidden {
            display: none;
        }

        #start-title {
            font-size: 3rem;
            font-weight: 900;
            background: linear-gradient(90deg, #e94560, #ff6b9d, #4ecdc4);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            text-align: center;
            margin-bottom: 2rem;
        }

        #start-btn {
            padding: 1.5rem 4rem;
            font-size: 1.5rem;
            font-weight: 700;
            background: linear-gradient(135deg, #e94560, #c73e54);
            color: white;
            border: none;
            border-radius: 50px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
            animation: pulse 2s ease-in-out infinite;
        }

        #start-btn:hover {
            transform: scale(1.1);
            box-shadow: 0 10px 40px rgba(233, 69, 96, 0.5);
        }

        /* Winner overlay */
        #winner-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.9);
            display: none;
            justify-content: center;
            align-items: center;
            flex-direction: column;
            z-index: 2000;
        }

        #winner-overlay.show {
            display: flex;
        }

        #winner-text {
            font-size: 4rem;
            font-weight: 900;
            color: #fff;
            text-align: center;
            margin-bottom: 1rem;
            text-shadow: 0 0 30px rgba(233, 69, 96, 0.8);
            animation: pulse 1s ease-in-out infinite;
        }

        #winner-subtitle {
            font-size: 2rem;
            font-weight: 600;
            background: linear-gradient(90deg, #ffd700, #ffaa00, #ffd700);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            text-align: center;
        }

        #restart-btn {
            margin-top: 2rem;
            padding: 1rem 3rem;
            font-size: 1.2rem;
            font-weight: 700;
            background: linear-gradient(135deg, #e94560, #c73e54);
            color: white;
            border: none;
            border-radius: 50px;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        #restart-btn:hover {
            transform: scale(1.05);
            box-shadow: 0 10px 30px rgba(233, 69, 96, 0.4);
        }

        /* Sound control */
        #sound-control {
            position: fixed;
            top: 80px;
            right: 20px;
            z-index: 1500;
            background: rgba(0, 0, 0, 0.7);
            border-radius: 50px;
            padding: 0.5rem 1rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
            cursor: pointer;
            border: 1px solid rgba(255, 255, 255, 0.2);
            transition: background 0.3s;
        }

        #sound-control:hover {
            background: rgba(50, 50, 50, 0.8);
        }

        #sound-control span {
            color: white;
            font-size: 1.5rem;
        }

        @keyframes pulse {

            0%,
            100% {
                transform: scale(1);
            }

            50% {
                transform: scale(1.05);
            }
        }

        @media (max-width: 768px) {
            header h1 {
                font-size: 1.2rem;
            }

            #winner-text {
                font-size: 2.5rem;
            }

            #winner-subtitle {
                font-size: 1.2rem;
            }

            #start-title {
                font-size: 2rem;
            }
        }
    </style>
</head>

<body>
    <header>
        <h1>üé± DG Kutluola</h1>
    </header>

    <!-- Start screen - needed for audio autoplay policy -->
    <div id="start-overlay">
        <div id="start-title">üé± DG Kutluola</div>
        <button id="start-btn" onclick="startGame()">‚ñ∂Ô∏è BA≈ûLA</button>
    </div>

    <div id="sound-control" onclick="toggleSound()">
        <span id="sound-icon">üîä</span>
    </div>

    <div id="winner-overlay">
        <div id="winner-text"></div>
        <div id="winner-subtitle">KAZANDI! üèÜ</div>
        <button id="restart-btn" onclick="restartGame()">Tekrar Oyna</button>
    </div>

    <script>
        // ============================================
        // AYARLAR - BURADAN DEƒûƒ∞≈ûTƒ∞R
        // ============================================
        const PHOTO_SETTINGS = [
            { file: 'foto1.png', name: 'DOƒûUM G√úN√úN KUTLU OLSUN MERVE', winMusic: 'win1.mp3' },
            { file: 'foto2.png', name: 'DOƒûUM G√úN√úN KUTLU OLSUN EMƒ∞RHAN', winMusic: 'win2.mp3' },
            { file: 'foto3.png', name: 'DOƒûUM G√úN√úN KUTLU OLSUN DENƒ∞Z', winMusic: 'win3.mp3' }
        ];

        // Sava≈ü m√ºziƒüi dosya adƒ± (dgkutluola klas√∂r√ºne koy)
        const BATTLE_MUSIC_FILE = 'battle.wav';
        // ============================================

        // Physics constants
        const HEADER_HEIGHT = 70;
        const RESTITUTION = 0.98;
        const MIN_SPEED = 5;
        const MAX_SPEED = 12;

        // Game constants
        const MAX_HEALTH = 100;
        const DAMAGE_PER_HIT = 15;
        const DAMAGE_COOLDOWN = 500;

        let boxes = [];
        let particles = [];
        let confetti = [];
        let photos = [];
        let gameOver = false;
        let winner = null;
        let gameStarted = false;

        // Audio
        let audioContext;
        let battleMusic;
        let winMusic;
        let soundEnabled = true;

        // Initialize audio context
        function initAudio() {
            audioContext = new (window.AudioContext || window.webkitAudioContext)();

            // Load battle music
            battleMusic = new Audio(BATTLE_MUSIC_FILE);
            battleMusic.loop = true;
            battleMusic.volume = 0.3;

            // Preload win music
            for (let setting of PHOTO_SETTINGS) {
                let audio = new Audio(setting.winMusic);
                audio.preload = 'auto';
            }
        }

        // Collision sound using audio file
        let collisionSound;

        function initCollisionSound() {
            collisionSound = new Audio('collision.wav');
            collisionSound.volume = 0.5;
        }

        function playCollisionSound() {
            if (!soundEnabled) return;

            try {
                // Clone the audio to allow overlapping sounds
                const sound = collisionSound.cloneNode();
                sound.volume = 0.5;
                sound.play().catch(e => { });
            } catch (e) {
                console.log('Sound error:', e);
            }
        }

        // Play wall hit sound (higher pitched)
        function playWallSound() {
            if (!soundEnabled || !audioContext) return;

            try {
                const oscillator = audioContext.createOscillator();
                const gainNode = audioContext.createGain();

                oscillator.connect(gainNode);
                gainNode.connect(audioContext.destination);

                oscillator.frequency.setValueAtTime(300, audioContext.currentTime);
                oscillator.frequency.exponentialRampToValueAtTime(100, audioContext.currentTime + 0.08);

                oscillator.type = 'triangle';

                gainNode.gain.setValueAtTime(0.15, audioContext.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.1);

                oscillator.start(audioContext.currentTime);
                oscillator.stop(audioContext.currentTime + 0.1);
            } catch (e) { }
        }

        // Play death sound
        function playDeathSound() {
            if (!soundEnabled || !audioContext) return;

            try {
                const oscillator = audioContext.createOscillator();
                const gainNode = audioContext.createGain();

                oscillator.connect(gainNode);
                gainNode.connect(audioContext.destination);

                oscillator.frequency.setValueAtTime(400, audioContext.currentTime);
                oscillator.frequency.exponentialRampToValueAtTime(50, audioContext.currentTime + 0.5);

                oscillator.type = 'sawtooth';

                gainNode.gain.setValueAtTime(0.2, audioContext.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.5);

                oscillator.start(audioContext.currentTime);
                oscillator.stop(audioContext.currentTime + 0.5);
            } catch (e) { }
        }

        function startBattleMusic() {
            if (battleMusic && soundEnabled) {
                battleMusic.currentTime = 0;
                battleMusic.play().catch(e => console.log('Music blocked:', e));
            }
        }

        function stopBattleMusic() {
            if (battleMusic) {
                battleMusic.pause();
                battleMusic.currentTime = 0;
            }
        }

        function playWinMusic(playerIndex) {
            if (!soundEnabled) return;

            winMusic = new Audio(PHOTO_SETTINGS[playerIndex].winMusic);
            winMusic.volume = 0.5;
            winMusic.play().catch(e => console.log('Win music error:', e));
        }

        function stopWinMusic() {
            if (winMusic) {
                winMusic.pause();
                winMusic.currentTime = 0;
            }
        }

        function toggleSound() {
            soundEnabled = !soundEnabled;
            document.getElementById('sound-icon').textContent = soundEnabled ? 'üîä' : 'üîá';

            if (!soundEnabled) {
                stopBattleMusic();
                stopWinMusic();
            } else if (gameStarted && !gameOver) {
                startBattleMusic();
            }
        }

        function startGame() {
            document.getElementById('start-overlay').classList.add('hidden');
            gameStarted = true;
            initAudio();
            initCollisionSound();
            startBattleMusic();
        }

        // Preload photos
        function preload() {
            for (let i = 0; i < PHOTO_SETTINGS.length; i++) {
                photos[i] = loadImage(PHOTO_SETTINGS[i].file,
                    () => console.log('Fotoƒüraf y√ºklendi: ' + PHOTO_SETTINGS[i].file),
                    () => console.log('Fotoƒüraf bulunamadƒ±: ' + PHOTO_SETTINGS[i].file)
                );
            }
        }

        // Ball class with health
        class Ball {
            constructor(x, y, size, color1, color2, photo, name, mass, index) {
                this.pos = createVector(x, y);
                this.vel = createVector(random(-4, 4), random(-4, 4));
                if (this.vel.mag() < MIN_SPEED) {
                    this.vel.setMag(MIN_SPEED);
                }
                this.acc = createVector(0, 0);
                this.size = size;
                this.radius = size / 2;
                this.mass = mass;
                this.color1 = color1;
                this.color2 = color2;
                this.photo = photo;
                this.name = name;
                this.index = index;
                this.rotation = 0;
                this.angularVel = random(-0.01, 0.01);

                this.health = MAX_HEALTH;
                this.maxHealth = MAX_HEALTH;
                this.alive = true;
                this.lastDamageTime = 0;
                this.damageFlash = 0;
            }

            takeDamage(amount) {
                let now = millis();
                if (now - this.lastDamageTime < DAMAGE_COOLDOWN) return false;

                this.health -= amount;
                this.lastDamageTime = now;
                this.damageFlash = 10;

                if (this.health <= 0) {
                    this.health = 0;
                    this.alive = false;
                    this.createDeathParticles();
                    playDeathSound();
                }
                return true;
            }

            createDeathParticles() {
                for (let i = 0; i < 30; i++) {
                    particles.push(new Particle(this.pos.x, this.pos.y, this.color1, true));
                }
            }

            applyForce(force) {
                let f = p5.Vector.div(force, this.mass);
                this.acc.add(f);
            }

            update() {
                if (!this.alive) return;

                this.vel.add(this.acc);
                this.pos.add(this.vel);
                this.acc.mult(0);

                this.angularVel *= 0.95;
                this.angularVel = constrain(this.angularVel, -0.02, 0.02);
                this.rotation += this.angularVel;

                let speed = this.vel.mag();
                if (speed < MIN_SPEED) this.vel.setMag(MIN_SPEED);
                if (speed > MAX_SPEED) this.vel.setMag(MAX_SPEED);

                if (this.damageFlash > 0) this.damageFlash--;

                this.checkWalls();
            }

            checkWalls() {
                let hitWall = false;

                if (this.pos.x - this.radius < 0) {
                    this.pos.x = this.radius;
                    this.vel.x *= -1;
                    this.createWallParticles(0, this.pos.y);
                    hitWall = true;
                }
                if (this.pos.x + this.radius > width) {
                    this.pos.x = width - this.radius;
                    this.vel.x *= -1;
                    this.createWallParticles(width, this.pos.y);
                    hitWall = true;
                }
                if (this.pos.y - this.radius < HEADER_HEIGHT) {
                    this.pos.y = HEADER_HEIGHT + this.radius;
                    this.vel.y *= -1;
                    this.createWallParticles(this.pos.x, HEADER_HEIGHT);
                    hitWall = true;
                }
                if (this.pos.y + this.radius > height) {
                    this.pos.y = height - this.radius;
                    this.vel.y *= -1;
                    this.createWallParticles(this.pos.x, height);
                    hitWall = true;
                }

                if (hitWall) playWallSound();
            }

            createWallParticles(x, y) {
                for (let i = 0; i < 3; i++) {
                    particles.push(new Particle(x, y, color(255, 255, 255, 150), false));
                }
            }

            display() {
                if (!this.alive) return;

                push();
                translate(this.pos.x, this.pos.y);
                rotate(this.rotation);

                if (this.damageFlash > 0) {
                    noFill();
                    stroke(255, 0, 0, this.damageFlash * 25);
                    strokeWeight(5);
                    ellipse(0, 0, this.size + 20, this.size + 20);
                }

                noStroke();
                fill(0, 0, 0, 80);
                ellipse(4, 4, this.size + 5, this.size + 5);

                if (this.photo && this.photo.width > 0) {
                    stroke(255, 255, 255, 100);
                    strokeWeight(3);
                    fill(30);
                    ellipse(0, 0, this.size + 6, this.size + 6);

                    push();
                    beginShape();
                    for (let a = 0; a < TWO_PI; a += 0.1) {
                        vertex(cos(a) * this.radius, sin(a) * this.radius);
                    }
                    endShape(CLOSE);

                    drawingContext.save();
                    drawingContext.clip();
                    imageMode(CENTER);
                    image(this.photo, 0, 0, this.size, this.size);
                    drawingContext.restore();
                    pop();
                } else {
                    let gradientSteps = 15;
                    for (let i = gradientSteps; i > 0; i--) {
                        let inter = map(i, 0, gradientSteps, 0, 1);
                        let c = lerpColor(this.color1, this.color2, inter);
                        let size = map(i, 0, gradientSteps, this.size * 0.3, this.size);
                        fill(c);
                        noStroke();
                        ellipse(0, 0, size, size);
                    }
                    fill(255, 255, 255, 60);
                    arc(0, -this.size * 0.15, this.size * 0.5, this.size * 0.3, PI, TWO_PI);
                }

                noFill();
                stroke(255, 255, 255, 30);
                strokeWeight(2);
                ellipse(0, 0, this.size + 2, this.size + 2);

                pop();

                this.drawHealthBar();
            }

            drawHealthBar() {
                let barWidth = this.size * 0.9;
                let barHeight = 10;
                let barX = this.pos.x - barWidth / 2;
                let barY = this.pos.y + this.radius + 15;

                fill(40);
                stroke(60);
                strokeWeight(2);
                rect(barX, barY, barWidth, barHeight, 5);

                let healthPercent = this.health / this.maxHealth;
                let healthColor;
                if (healthPercent > 0.6) {
                    healthColor = color(78, 205, 196);
                } else if (healthPercent > 0.3) {
                    healthColor = color(255, 200, 50);
                } else {
                    healthColor = color(233, 69, 96);
                }

                noStroke();
                fill(healthColor);
                rect(barX + 2, barY + 2, (barWidth - 4) * healthPercent, barHeight - 4, 3);

                fill(255);
                textAlign(CENTER, CENTER);
                textSize(9);
                textFont('Inter');
                text(Math.ceil(this.health), this.pos.x, barY + barHeight / 2);
            }

            collidesWith(other) {
                if (!this.alive || !other.alive) return false;
                let d = p5.Vector.dist(this.pos, other.pos);
                return d < this.radius + other.radius;
            }
        }

        // Particle class
        class Particle {
            constructor(x, y, col, large) {
                this.pos = createVector(x, y);
                this.vel = p5.Vector.random2D().mult(random(large ? 3 : 1, large ? 8 : 4));
                this.acc = createVector(0, large ? 0.1 : 0.05);
                this.lifespan = large ? 255 : 200;
                this.col = col;
                this.size = random(large ? 5 : 3, large ? 12 : 7);
            }

            update() {
                this.vel.add(this.acc);
                this.pos.add(this.vel);
                this.lifespan -= 6;
            }

            display() {
                noStroke();
                let c = color(red(this.col), green(this.col), blue(this.col), this.lifespan);
                fill(c);
                ellipse(this.pos.x, this.pos.y, this.size);
            }

            isDead() {
                return this.lifespan <= 0;
            }
        }

        // Confetti class
        class Confetti {
            constructor() {
                this.pos = createVector(random(width), random(-100, -10));
                this.vel = createVector(random(-2, 2), random(3, 7));
                this.size = random(8, 15);
                this.rotation = random(TWO_PI);
                this.rotationSpeed = random(-0.2, 0.2);
                this.col = color(
                    random([255, 233, 78, 255, 147]),
                    random([215, 69, 205, 200, 112]),
                    random([0, 96, 196, 50, 219])
                );
                this.shape = floor(random(3));
            }

            update() {
                this.vel.x += random(-0.1, 0.1);
                this.pos.add(this.vel);
                this.rotation += this.rotationSpeed;
            }

            display() {
                push();
                translate(this.pos.x, this.pos.y);
                rotate(this.rotation);
                fill(this.col);
                noStroke();

                if (this.shape === 0) {
                    rectMode(CENTER);
                    rect(0, 0, this.size, this.size * 0.6);
                } else if (this.shape === 1) {
                    ellipse(0, 0, this.size, this.size * 0.6);
                } else {
                    triangle(-this.size / 2, this.size / 2, this.size / 2, this.size / 2, 0, -this.size / 2);
                }
                pop();
            }

            isDead() {
                return this.pos.y > height + 50;
            }
        }

        // Collision resolution
        function resolveCollision(ball1, ball2) {
            let collisionNormal = p5.Vector.sub(ball2.pos, ball1.pos);
            let distance = collisionNormal.mag();
            let minDist = ball1.radius + ball2.radius;

            if (distance === 0 || distance > minDist) return false;

            collisionNormal.normalize();
            let relativeVel = p5.Vector.sub(ball1.vel, ball2.vel);
            let velAlongNormal = p5.Vector.dot(relativeVel, collisionNormal);

            if (velAlongNormal > 0) return false;

            let j = -(1 + RESTITUTION) * velAlongNormal;
            j /= (1 / ball1.mass) + (1 / ball2.mass);

            let impulse = p5.Vector.mult(collisionNormal, j);
            ball1.vel.add(p5.Vector.div(impulse, ball1.mass));
            ball2.vel.sub(p5.Vector.div(impulse, ball2.mass));

            let overlap = minDist - distance;
            if (overlap > 0) {
                let separation = p5.Vector.mult(collisionNormal, overlap / 2 + 2);
                ball1.pos.sub(separation);
                ball2.pos.add(separation);
            }

            let tangent = createVector(-collisionNormal.y, collisionNormal.x);
            let tangentVel = p5.Vector.dot(relativeVel, tangent);
            ball1.angularVel += tangentVel * 0.001;
            ball2.angularVel -= tangentVel * 0.001;

            let collisionPoint = p5.Vector.add(ball1.pos, p5.Vector.mult(collisionNormal, ball1.radius));
            let particleColor = lerpColor(ball1.color1, ball2.color1, 0.5);
            for (let i = 0; i < 8; i++) {
                particles.push(new Particle(collisionPoint.x, collisionPoint.y, particleColor, false));
            }

            // Play collision sound
            playCollisionSound();

            // Damage both
            ball1.takeDamage(DAMAGE_PER_HIT);
            ball2.takeDamage(DAMAGE_PER_HIT);

            return true;
        }

        function createBalls() {
            boxes = [];

            let ballSize = min(width, height) * 0.2;
            ballSize = constrain(ballSize, 100, 200);

            const ballColors = [
                { c1: color(233, 69, 96), c2: color(199, 62, 84) },
                { c1: color(78, 205, 196), c2: color(61, 185, 177) },
                { c1: color(255, 230, 109), c2: color(230, 207, 98) }
            ];

            for (let i = 0; i < 3; i++) {
                boxes.push(new Ball(
                    random(ballSize + 50, width - ballSize - 50),
                    random(HEADER_HEIGHT + ballSize + 50, height - ballSize - 50),
                    ballSize,
                    ballColors[i].c1,
                    ballColors[i].c2,
                    photos[i],
                    PHOTO_SETTINGS[i].name,
                    1.0,
                    i
                ));
            }
        }

        function setup() {
            createCanvas(windowWidth, windowHeight);
            createBalls();
        }

        function showWinner(ball) {
            gameOver = true;
            winner = ball;

            stopBattleMusic();
            playWinMusic(ball.index);

            document.getElementById('winner-text').textContent = ball.name;
            document.getElementById('winner-overlay').classList.add('show');

            for (let i = 0; i < 150; i++) {
                setTimeout(() => {
                    confetti.push(new Confetti());
                }, i * 20);
            }
        }

        function restartGame() {
            gameOver = false;
            winner = null;
            confetti = [];
            particles = [];
            stopWinMusic();
            document.getElementById('winner-overlay').classList.remove('show');
            createBalls();
            startBattleMusic();
        }

        function draw() {
            background(0);

            stroke(25);
            strokeWeight(1);
            let gridSize = 50;
            for (let x = 0; x < width; x += gridSize) {
                line(x, HEADER_HEIGHT, x, height);
            }
            for (let y = HEADER_HEIGHT; y < height; y += gridSize) {
                line(0, y, width, y);
            }

            for (let i = particles.length - 1; i >= 0; i--) {
                particles[i].update();
                particles[i].display();
                if (particles[i].isDead()) particles.splice(i, 1);
            }

            for (let i = confetti.length - 1; i >= 0; i--) {
                confetti[i].update();
                confetti[i].display();
                if (confetti[i].isDead()) confetti.splice(i, 1);
            }

            if (gameOver && confetti.length < 100 && random() < 0.3) {
                confetti.push(new Confetti());
            }

            if (!gameOver && gameStarted) {
                for (let ball of boxes) {
                    ball.update();
                }

                for (let i = 0; i < boxes.length; i++) {
                    for (let j = i + 1; j < boxes.length; j++) {
                        if (boxes[i].collidesWith(boxes[j])) {
                            resolveCollision(boxes[i], boxes[j]);
                        }
                    }
                }

                let aliveBalls = boxes.filter(b => b.alive);
                if (aliveBalls.length === 1) {
                    showWinner(aliveBalls[0]);
                }
            }

            for (let ball of boxes) {
                ball.display();
            }
        }

        function mousePressed() {
            if (gameOver || !gameStarted) return;

            for (let ball of boxes) {
                if (!ball.alive) continue;
                let d = dist(mouseX, mouseY, ball.pos.x, ball.pos.y);
                if (d < ball.radius) {
                    let force = p5.Vector.sub(ball.pos, createVector(mouseX, mouseY));
                    force.setMag(8);
                    ball.vel.add(force);

                    for (let i = 0; i < 5; i++) {
                        particles.push(new Particle(ball.pos.x, ball.pos.y, ball.color1, false));
                    }
                }
            }
        }

        function windowResized() {
            resizeCanvas(windowWidth, windowHeight);
            for (let ball of boxes) {
                ball.pos.x = constrain(ball.pos.x, ball.radius, width - ball.radius);
                ball.pos.y = constrain(ball.pos.y, HEADER_HEIGHT + ball.radius, height - ball.radius);
            }
        }
    </script>
</body>

</html>